---
title: 第 12 章 对抗攻击
lang: zh-CN
date: 2025-03-22 16:09:30
author: datawhalechina
cover:
tags:
hidden: true
recommend: false
---

# 第 12 章 对抗攻击  

本章介绍人工智能中的对抗攻击。之前我们已经了解了各式各样的神经网络，这些神经网络对于不同的输入输出类别都有非常高的正确率，我们期待可以把这些技术用在真正的应用上。但是把这些网络真正的使用起来，仅仅提高它们的正确率是不够的。它们需要能够应付来自人类的恶意，也就是说，它们需要能够对抗来自外界的攻击。有时候神经网络的工作是为了要检测一些有恶意的行为，它要检测的对象会去想办法骗过网络，所以我们不仅要在一般的情况下得到高的正确率，还需要它在有人试图想要欺骗它的情况下也得到高的正确率。举例来说，我们会使用神经网络来做电子邮件的过滤，检测它是不是垃圾邮件。所以对于一个垃圾邮件的发信者而言，他也会想尽办法避免他的邮件被分类为垃圾邮件。我们的模型需要对于此有极高的鲁棒性才能被广泛使用。所以进行有关对抗攻击的研究是非常有必要的。  

## 12.1 对抗攻击简介  

我们首先看看所谓人类的恶意是什么样子，以下是一个真正的例子，如图 12.1 所示。之前我们已经训练了图像识别模型，给它一张照片，它可以告诉我们这张照片属于什么类别。那我们要做的攻击就是在这张照片上面加入一个非常小的噪声，具体方法是一张照片可以被看作是一个矩阵，我们在这个矩阵的每一个数据上都加入一个小小的噪声，然后把这个加入噪声以后的照片输入到网络中查看输出的分类结果。一般，这个噪声都非常非常地小，小到人肉眼没有办法看出来，图中的例子为一个示意图，我们把有被加噪声的照片叫做受攻击的图像，没有被加噪声的照片叫做原始图像。原始图像输入到网络里面的输出是猫，我们作为攻击方期待受攻击图像的输出不可以是猫，要变成其他的东西。攻击大致上可以分成两种类型，一种是无目标攻击，也就是说我们只要受攻击图像的输出不是猫就算成功了。还有另外一种更困难的攻击，即有目标攻击，我们希望受攻击图像的输出是狮子等等，也就是说我们希望网络不止它输出不能是猫，还要输出别的具体的东西，这样才算是成功攻击。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/fa6fbc8096788f67227b123a2fdbd32436e76a1001fd36f60243c142fab28bda.jpg)  
图 12.1 网络攻击的案例  

我们可以加入一个人肉眼看不到的噪声去改变网络的输出，比如选用一个50 层的ResNet作为图像分类器，如图 12.2 所示。当我们把一个原始没有被攻击的图片，输入到 50 层的 ResNet的时候，它的输出是虎斑猫（猫科的一种），同时还有一个置信得分，也就是说模型认为这张图片是虎斑猫的概率是多少。置信得分也就是做完 Softmax 以后得到的分数，假设图像分类的类别有 2000 类，这 2000 个类别都会有一个分数，一定都介于 0 到 1 之间，而且 2000 个类别的分数合起来一定是 1。那么在这个例子中，虎斑猫的分数是 0.64，也就是说 ResNet 认为这张图片是虎斑猫的概率是 $64\%$ 。接下来，我们将原始图像加入一些噪声，希望成功攻击的目标是把虎斑猫变成海星，加入噪声以后的图片为右侧图片（噪声非常小，肉眼无法分辨)，我们把它输入到 ResNet 中，得到的输出是海星，而且置信得分是 1。本来网络还没有那么确定这是不是一只猫，现在它百分之百确定它就是海星。所以这里人类看不出的图像，我们的网络反而会非常肯定地告诉我们天差地远的错误答案，这就是攻击的效果。这个案例不是一个特例，我们可以把这只猫轻易地变成任何的东西。我们同时也不必怀疑网络的分类能力，因为这是一个 50 层的 ResNet，它的分类能力是非常强的。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/1c93c6ad548751b0bbf7cb80c375b437c64295adc4e712a1a32b71586e1477ee.jpg)  
图 12.2 网络攻击的影响网络输出结果  

当然，如果我们加入的只是一般的噪声，网络并不一定会犯错，如图 12.3 所示。左上角是原来的图片，我们现在加入一个肉眼可见的噪声，如左下角所示，这个时候 ResNet 还是可以正确地识别出这是一只猫。只不过换了品种。那我们把噪声加得更大一点，变为右上角的图片，这个时候 ResNet 会说这是波斯猫，这个猫看起来毛茸茸的，所以因此 ResNet 觉得它看到了波斯猫。那如果噪声再加更大一点，如右下角，这个时候 ResNet 就会识别为壁炉，因为它觉得前面的噪声是屏风，而后面这个橙色的猫就是火焰。它虽然犯错，但是错的是有尊严的，是有道理的。  

## 12.2 如何进行网络攻击  

在讲为什么噪声会影响识别结果之前，我们来看看攻击究竟是如何做到的。如图 12.4 所示，我们有一个网络 $f$ ，它的输入是一张图片 $x_{0}$ ，输出是一个分布，这个分布表示的是这张图片属于每个类别的概率。假设网络的参数是固定的，不讨论网络的参数部分。我们现在要做的是，找到一张新的图片 $x$ ，当我们把这张图片 $x$ 输入到网络 $f$ 里以后，它的输出 $y$ 和正确答案 $\hat{y}$ 的差距越大越好。我们现在是无目标攻击，所以我们只需要两者的差距越大越好，而不需要把它变成某个特定的类别。  

这里我们要解一个优化的问题，我们先定一个损失函数 $L$ ，表示网络输出 $y$ 和正确答案$\hat{y}$ 之间的差距。我们一般做分类问题时，用交叉熵损失 $-e(y,\hat{y})$ 表示网络输出 $y$ 和正确答案$\hat{y}$ 的交叉熵，我们希望这个交叉熵越大越好，所以在前面加一个负号。那我们的目标是找到一张图片 $x$ ，使得损失 $L$ 最小。 $L(x)$ 越小表示两者的距离越大，说明攻击效果越好，这个是没有目标的攻击。如果是有目标的攻击，我们会先设定好我们的目标，这里用 $y^{t a r g e t}$ 来代表我们的目标。我们希望 $y$ 不止与 $\hat{y}$ 越远越好，还要与 $y^{t a r g e t}$ 越近越好。比如说，我们的 $y^{t a r g e t}$ 是一条鱼，那希望输出的 $y$ 不止是猫的机率越低越好，还要保证鱼的机率还要越高越好。所以我们的损失函数为 $L(x)=-e(y,\hat{y})+e(y,y^{t a r g e t})$ ，这里的 $e$ 表示同样表示交叉熵。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/97b21239b04178bc3866db7fd3208a9cfba3d209f6ae2df7dee8f1aab68818ae.jpg)  
图 12.3 噪声对于 ResNet 识别结果的影响  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/4c803a2c3e94fa5617638c4d561b89bc7d0329043f18b4ba8246f3a25e623ae3.jpg)  
图 12.4 如何进行攻击  

另外需要注意的是，我们希望找一个 $x$ 去最小化损失的同时还需要保证加入的噪声越小越好，也就是我们新找到的图片可以欺骗过网络的图片，并且尽量与原来的图片要越相似越好。所以我们在解这个优化问题的时候，还会多加入一个限制，即 $x$ 与 $x_{0}$ 之间的差距要小于某个阈值 $\varepsilon$ ，即 $d(x_{0},x)\leq\varepsilon$ ，这个阈值是根据人类的感知能力来决定的。如果 $x$ 与 $x_{0}$ 之间的差距太大（大于 $\varepsilon$ ），人类就会发现这是一张带有噪声的图片，所以我们要保证这个差距不要太大。这个限制也可以写成 $L_{2}$ 范数的形式，即 $\|x_{0}-x\|_{2}\leq\varepsilon$ 。  

为了符号的方便起见，我们假设 $x$ 是一个向量， $x_{0}$ 也是一个向量，那这个向量的维度就是图片的像素数，比如说我们的图片是 $224\times224$ 的，那这个向量的维度就是 $224\times224\times3$ 。这两个向量相减，我们叫它 $\Delta x$ ，我们可以使用 L2 范数当做它们的距离，即 $d(x_{0},x)=$ $\|\Delta x\|_{2}$ ，其也就等于 $(\Delta x_{1})^{2}+(\Delta x_{2})^{2}+(\Delta x_{3})^{2}\dots$ ，或者根据 L2 范数的定义，也可以写成$\sqrt{(\Delta x_{1})^{2}+(\Delta x_{2})^{2}+(\Delta x_{3})^{2}\dotsb\cdot\dotsb}$ 。还有另外一个距离的定义L-无穷范数，它的定义是 $\|\Delta x\|_{\infty}=$ $\operatorname*{max}(|\Delta x_{1}|,|\Delta x_{2}|,|\Delta x_{3}|\dots)$ ，即取这个向量里面每一维绝对值最大的那个值，最大的值就代表 $x$ 和 $x_{0}$ 之间的距离。  

那 L2 范数和 L-无穷范数到底哪一个在攻击的时候是比较好的距离呢？我们来看一下这个例子，如图 12.5 所示，假设我们有一张图片，这个图片只有四个像素。现在我们把这张图片做两种不同的变化，第一个变化是这四个像素的颜色都做了非常小的改变，第二种变化是只有右下角像素的颜色被大改了。对于 L2 范数他们的数值基本是相同的，因为前者四个像素都改过而后者只有一个像素改过。但是对于 L-无穷范数，这两个数值是不一样的，因为 L-无穷只在意最大的变化量，前者的最大变化量是非常小的，而后者的最大变化量是非常大的。所以如果从这个例子来看 L-无穷和 L2 范数中，L-无穷范数更加符合人类的感知能力，因为人类的感知能力更多的是关注最大的变化量，而不是关注所有的变化量。所以要避免被人类仅仅是 L2 小是不够的，我们要让 L-无穷小才比较不会被发现。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/65d38563b5eadd20e89e43264286f348c058616dae6cf46f7f9463c5f06e5e4f.jpg)  
L-∞o范数小   
图 12.5 基于 L2 范数和无穷范数的距离的比较  

实际应用中其实也要凭领域知识来定义这个距离，我们刚才举的例子是图像上的例子，如果我们今天要攻击的对象是一个和语音相关的系统，也就是我们的 $x$ 和 $x_{0}$ 都是声音信号，那什么样的声音信号对人类来说听起来有差距，那就不见得是 L2 与 L-无穷了，我们就需要去研究人类的听觉系统，看看人类对什么频态的变化特别敏感，再根据人类的听觉系统来制定比较适合的衡量方式。  

我们继续分析一下这个优化问题如何解，我们要做的事情是找一个 $x$ 来最小化损失值，与此同时我们还要保证 $x$ 和 $x_{0}$ 之间的距离不要太大。如果我们先把这个限制拿掉，那这个问题就变成了我们之前讲过的优化问题，我们要找一个 $x$ 来最小化损失函数，这个问题我们是会解的。我们只需要把输入的那一张图像看作是网络参数一部分，然后最小化损失函数就好了，并且现在网络参数是固定的，我们只去调输入部分，然后使用梯度下降来最小化一个损失就可以了。  

但是现在我们还有一个限制，就是我们要保证 $x$ 和 $x_{0}$ 之间的距离不要太大，这里直接在梯度更新以后再加一个限制即可。举例来说，如图 12.6 所示，假设我们现在用的是 L-无穷范数，黄色点是 $x_{0}$ ， $x$ 它可以存在的范围就只有这个方形框，因为 L-无穷是考虑 $X_{0}$ 和 $x$ 之间最大的差距，所以出了这个方形框的差距就会超过 $\varepsilon$ 。所以使用梯度下降去更新 $x$ 以后，它一定还要落在这个方框里面才行。所以只要更新梯度后 $x$ 超出了方框，我们就把它拉回来就可以了。也就是在方框里面找一个与蓝色的点最近的位置，然后把蓝色的点拉进来就结束了。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/58db717f8040a3015a86194408b4afca43f07cc196809a30503750d8fa8049cd.jpg)  
图 12.6 加入限制的优化问题解法分析  

## 12.3 快速梯度符号法  

所谓的攻击还有很多不同的变形，不过大同小异，它们通常要么是限制不一样，要么是优化的方法不一样。接下来再介绍一个最简单的攻击的方法，这个方法叫做快速梯度符号法，全称是快速梯度符号法（Fast Gradient Sign Method，FGSM）。本来一般我们在做梯度下降的时候，需要迭代更新参数很多次，但是这个方法只需要更新一次参数就可以了，原理如图 12.7 所示。  

具体来讲，FGSM 将原始的梯度 $g$ 做了一个特别的设计，不是直接使用梯度下降的值，而是取一个符号函数，也就是值大于 0，我们就输出 1，值小于 0，就输出 $-1$ 。所以加了符号函数以后，这个梯度 $g$ 向量要么是 1 要么是 $-1$ 。对于学习率 $\eta$ ，直接将其设置为 $\varepsilon$ ，这样会得到的效果是我们攻击完以后，更新后的 $x$ 一定落在这个蓝色框四个角落。因为梯度 $g$ 要么是 1 要么是 $-1$ ，再乘以 $\varepsilon$ 后， $x$ 要么往右边移动 $\varepsilon$ ，要么往左边移动 $\varepsilon$ ，要么往上边移动$\varepsilon$ ，要么往下边移动 $\varepsilon$ 。它一定会挪到这个方形的四个角落的地方，所以这个攻击方法就是这么简单。有一个问题，如果我多攻击几次多跑几个迭代，结果会不会更好？其实会更好，但是这个方法就是这么简单，只需要一次迭代就可以了。那但是多跑几个迭代的坏处是有可能一不小心就出界，这样还需要用之前的方法把它拉回来。图 12.8 就是基于迭代的 FGSM，其效果要比原始的 FGSM 好，但是更加复杂，可以将图 12.7 和图 12.8 简单对比。  

## 12.4 白盒攻击与黑盒攻击  

我们以上介绍的其实都是比较有代表性的白盒攻击，也就是说我们知道模型的参数，知道模型的结构，知道模型的输入输出，知道模型的损失函数，知道模型的梯度等等。我们知道模型的参数，所以才有办法计算梯度，才有办法去在图像上加上噪声。那像这种知道模型参数的攻击叫做白盒攻击。但是因为白盒攻击需要知道网络的参数，所以也许白盒击不是很危险，因为很多线上的服务模型，我们很难不知道它的参数是什么，所以也许要攻击一个线上的服务并没有那么容易。换一个角度，其实如果要保护我们的模型不被别人攻击，我们只要注意不要随便把自己的模型放到网络上公开让大家取用就好。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/3a00d3fdd70d516fde004878f2fec5fa533627dfc5607a73a47a96678e48b574.jpg)  
图 12.7 快速梯度符号法-FGSM  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/83d93b5414430775fc06289cba477f8954847b72f68d50c9995beea8e38b67d2.jpg)  
图 12.8 基于迭代的快速梯度符号法  

其实我们想简单了，因为我们的模型参数是可以通过一些方法来反推出来的，这个方法叫做黑盒攻击，也就是说我们不知道模型的参数，但是我们可以通过一些方法来反推出来。具体来讲，如果有一个模型我们无法获知其中的具体参数，但是知道该网络是用什么样的训练数据训练出来的话，我们就可以去训练一个代理网络，让该网络来模仿我们要攻击的对象。如果它们都使用同样的训练数据训练模型的话，也许它们就会有一定程度的相似度。如果代理网络与要被攻击的网络有一定程度的相似的话，那我们只要对代理网络进行攻击，也许原始的网络也会被攻击成功。整个过程如图 12.9 所示。  

如果我们没有训练数据，并且不知道被攻击对象是用什么样的训练数据的话怎么办呢？其实也很简单，我们就直接将一些现有的图片输入进需要被攻击的模型，然后看看它会输出什么，然后再把输入输出的成对数据拿去训练一个模型的话，我们就有可能可以训练出一个类似的网络，也就是我们的代理网络了，我们再对于代理网络进行攻击即可。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/e2a7ae91fe584a5b4fe2dd1e1fe98fac1e8b7ccdb41b47b8f860b206e86dab9d.jpg)  
图 12.9 黑盒攻击  

黑盒攻击相对来说还是很容易成功的，如图 12.10 所示，这是一篇论文的结果。有 5 个不同的网络架构，ResNet-152、ResNet-101、ResNet-50、VGG-16 和 GoogLeNet。每一列代表要被攻击的网络，每一行代表代理网络。对角线的地方代表是代理网络和要被攻击的网络是一模一样的，所以这个情况就不是黑盒攻击，对角线的地方其实是白盒攻击。例如，你使用ResNet-152 当做代理网络攻击一模一样的网络，那其实攻击就很容易成功了。表中的数值是要被攻击模型的正确率，这个值越低越好，越低的正确率代表我们的攻击越成功。我们可以发现对角线，也就是白盒攻击的部分，这个攻击的成功率是百分之百，模型的正确率是 $0\%$ ，也就表示攻击总是会成功。但如果在非对角线的地方，也就是黑盒攻击时，我们会发现攻击的成功率也是非常高的，例如，用 ResNet-101 当代理网络去攻击 ResNet-152 得到的正确率是$19\%$ 。黑盒攻击模型的正确率是比白盒攻击还要高的，但是其实这些正确率也都非常低（都低于 $50\%$ )，所以显然黑盒攻击也有一定的成功的可能性。实际上黑盒攻击是在无目的攻击的时候比较容易成功，有目标攻击的时候就不太容易成功。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/364ca472691365d328e3d240b8e769dd3f9dc83d0f9876aa1dd7c74ad730c667.jpg)  
图 12.10 黑盒攻击的案例  

如果要增加黑盒攻击的成功率，我们可以使用集成学习的方法，也就是使用多个网络来攻击，这样的话，我们就可以提高攻击的成功率。如图 12.11 所示，这里有 5 个网络，我们可以使用这 5 个网络来攻击，然后看看攻击的成功率会不会提高。每一列还代表要被攻击的网络，那每一个行有所不同，你会发现这个每一个模型的名字前面放了一个减号，其代表把这 5个模型都集合起来，但拿掉 ResNet-152，找一张图像攻击这 4 个网络。我们观察图 12.11 ，与之前不同，非对角线的地方是白攻击，非对角线模型正确率都变成 $0\%$ ，白盒攻击依然非常容易成功。对角线的地方是黑盒攻击，比如我们要攻击 ResNet-152，但我们没有用 ResNet-152，但是用了另外 4 个网络，所以对角线的地方才是黑盒攻击。所以使用集成的方式进行攻击的时候，黑盒攻击的成功率也是非常高的，都低于 $6\%$ 。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/734c2da8d1ff70ce7cf2f222ca31084a55fff79664426c97b52204e221494d73.jpg)  
图 12.11 集成学习的黑盒攻击  

那为什么黑盒攻击非常容易成功呢？下面介绍一个信服度较高的结论，它基于一个实验。图 12.12 上面的原点代表一张小丑鱼的图片，横轴和纵轴分别是把这张图片往两个不同的方向移动。横轴是在 VGG-16 上面可以攻击成功的方向，纵轴表示一个随机的方向。我们可以观察到横轴是让 VGG-16 可以攻击成功的方向，在其他的网络上面它们中间深蓝色的区域都很相近，其表示会被识别成小丑鱼的图片的范围。也就是说如果把这个小丑鱼的图片加上一个噪声这个矩阵在高维的空间中横向移动，基本上网络还是会觉得它是小丑鱼的图片。但是如果是往可以攻击成功 VGG-16 的方向来移动的话，那基本上其他网络也是有很高的机率可以被攻击成功的。对于小丑鱼这一个类别，它在攻击的方向上，可移动的范围特别窄，只要把这张图片稍微移动一下它就掉出会被识别成小丑鱼的区域范围之外了。  

对每一个网络来说，攻击的方向对不同的网络影响都是很类似的。所以有些人主张攻击会成功，主要的问题来自于数据而不是来自于模型。所以为什么机器会把这些加入非常小的噪声后的图片误判为另外一个物体，那可能是因为在数据本身它的特征就如此，在有限的数据上机器学到的就是这样的结论。所以对抗攻击会成功的原因，是来自于数据，当我们有足够的数据的时候，也许就有机会避免对抗攻击。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/89f28f35336926aca305dd9aca09715dabf2b2f24d2e7e5cb6cbfa4c739fc7f3.jpg)  
图 12.12 为什么黑盒攻击容易成功  

那攻击的信号我们希望它越小越好，那到底可以小到什么程度呢？其实已经有人成功地做出了单像素攻击，也就是我们只需要动图片里面的一个像素。举例来说，在图 12.13 的所有子图中都只动了一个像素，并且会把像素有改变的地方用红圈圈起来。我们希望动了图片中的一个像素，这个图像识别系统的判断就必须要有错误，每一个图片下方黑色的部分代表的是攻击前的结果，蓝色代表是攻击后的识别结果。其实单像素攻击还是有一些局限，它的攻击并没有非常成功。比如，图 12.13 左下角为一个茶壶，攻击时将某一个像素的颜色改变了，机器就会把茶壶识别为摇杆。这个就是基于单像素攻击的一个案例，但是它的攻击成功率并不是非常高，所以我们还是希望能够找到更好的攻击方式。  

比单像素更好的攻击方式是通用对抗攻击，也就是说我们只要找到一个攻击信号，这个攻击信号可以攻击所有的图片。之前，我们有 200 张图片，那我们就会分别找出不同的攻击信号来攻击不同的图片。那有没有可能只用一个信号，就成功攻击所有的图片呢？因为在现实使用中，我们不可能对于所有的图片都去找一个攻击信号，比如我们要攻击某一个监视系统，让这个监视系统的识别出错，我们不可能每一次都定制化的找出一个攻击信号，这个运算量可能会非常地大。但是如果通用攻击可以成功的话，我们只需要这个攻击信号部署在监视器的摄像头上，那么它不管什么样的图像都可以攻击成功了，也就是不管看到什么物体它都会识别错误从而达到了攻击效果。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/49e406aaf819bcc2502091cfb350a6920e30148ce22b863c378485c9d15a36b4.jpg)  
图 12.13 单像素攻击案例  

## 12.5 其他模态数据被攻击案例  

以上我们分析的都是图像攻击的案例，其实其他类型的数据也有类似的问题。我们以语音领域为例，现在经常有人使用语音合成或语音转换技术去模拟出某些人的声音，来达到诈骗的效果。所以为了检测真假声音，有一系列的研究在做这方面的工作，比如说如何检测声音是不是被合成出来的，或者如何检测声音是不是被转换出来的。目前虽然语音合成的系统往往都可以合出以假乱真的声音，但是这些以假乱真的声音它们大部分还是有固定的模式和特征，与真正的声音信号相比还是有一定程度的差异。这种差异可能人耳听不出来，但机器可以捕捉到。所以我们可以利用机器学习的方法来检测这些差异，从而达到检测声音是否是合成的目的。  

但是这些可以检测语音合成的系统，其实也会被轻易攻击。比如我们有一段人工合成的声音，人耳也可以听出来是合成的，所以用模型去检测其是否是合成的声音，模型可以有正确地输出。但是如果我们在刚才那段声音里面加入一点点噪声，这个噪声是人耳听不出来的，而这段声音加上这个微小噪声后，它听起来也没有合成得更好，但是同一个检测合成的模型就会觉得这段声音是真实的声音，而非合成的声音。  

## 12.6 现实世界中的攻击  

我们前面介绍的攻击都发生在虚拟世界中，都是把一张图像输入内存中以后才把噪声加上去。攻击也有可能会发生在真实世界中，举例来说，现在有很多人脸识别系统，如果我们从虚拟世界发动攻击，那得访问进人脸识别系统，然后有一个人脸输入我们自己再去加一个噪声，只有这样才能够骗过人脸识别系统。但是如果我们在现实世界中发动攻击，我们就不需要访问人脸识别系统，我们只需要在现实世界中加一个噪声就可以了，比如在脸上画一个妆等等。有篇文章发现可以制造神奇的眼镜，戴上这个眼镜以后我们就可以去欺骗人脸识别系统，如图 12.14 所示。这个眼镜看起来没有什么特别的，但是左边男人戴上这副眼镜以后人脸识别系统就会觉得他是右边这一个知名女艺人。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/6b6f81fee1116c943811cb4bb74087433fa954b6d25cae3e6fc90fd6081dbcf4.jpg)  
图 12.14 现实世界中人脸识别系统被攻击案例  

在这篇文章中作者们同时考虑了很多物理世界才会有的问题。首先，在物理世界我们在观看一个东西的时候，可以从多个角度去看。之前有人会觉得攻击也许不是那么危险，因为就是一张图像，我们加入某一个特定的噪声才能够让这张图像被识别错误。但在真实的物理世界中，我们可以从多个角度去看同一个物体，也许噪声骗过了某一个角度，但很难在所有的角度都骗过图像分类系统。这篇论文也涵盖了这个观点，它是从所有的角度去看这个有戴眼镜的人，他都会被识别成右边的女性。其次，这个文章也考虑了物理世界的特性，比如摄像头的清晰度是有限的，所以如果今天在这个眼镜上面加的噪声非常小，那有可能摄像头根本没有办法注意到。再者，这个眼镜是否真的能被做出来。这个论文考虑到某些颜色可能在电脑里和在真实世界里的表现会不一样，这样要求我们在设计这个眼镜的时候要考虑到这些问题。所以说真实物理世界中的攻击，它会比虚拟世界中的攻击更加困难，我们需要考虑的现实实际的问题也会更多。  

除了人脸识别系统可能受到攻击外，交通公路标志牌也有潜在的风险，可以通过各种手段来误导或攻击。例如，在图 12.15 中所示的标志牌上，可能会贴上某些标志或贴纸，以使识别系统无论从何种角度观察都会将其误认为是限速 45 公里每小时的标志，而不是停车标志。然而，一些研究者认为，这种方法可能会引起过于明显的警觉，因为当人们意识到路标被篡改时，很可能会迅速采取措施来纠正问题。因此，他们倾向于探讨更加隐蔽的攻击方式，如图 12.16所示。在这种情况下，数字 3 被拉长，以使人眼仍然可能看到它为”35”，但对于自动识别系统来说，可能会被错误地解释为限速 85 千米每小时。总之，交通标志牌的安全性也需要考虑，因为攻击者可能会尝试各种方法来误导或欺骗自动识别系统，这可能对交通安全产生潜在威胁。因此，研究和采取措施以保护交通标志的完整性和可信度是非常重要的。  

除此之外，我们再介绍另外一种攻击，叫做对抗性重编程（adversarial reprogram-ming)。它会将原来的图像识别系统，放一个像僵尸一样的东西去寄生它，让它做其本来不想做的事情。如图 12.17 所示，对抗重编程想做一个方块的识别系统，去数图片中方块的数量，但它不想训练自己的模型，它希望寄生在某一个已有的并且训练在 ImageNet 的模型上面。对抗重编程希望输入一张图片，这个图片里面如果有两个方块的时候，ImageNet 的模型就要输出“Goldfish”（金鱼），如果 3 个方块就输出“White Shark”（噬人鲨），如果 4 个方块就输出“Tiger Shark"（鼬鲨），以此类推。这样它就可以操控这个ImageNet 的模型，让它做它本来不想做的事情。具体的方法是就把要数方块的图片嵌入在这个噪声的中间，并且在这个方块的图片的周围加一些噪声，再把加噪声的图片输入到图像分类器里面，原来的图像分类器就会输出我们想要的结果。所以图 12.17 中的 4 个方块的图片，我们输入到 ImageNet 里面它输出老虎鲨，10 个方块的图片，ImageNet 的分类器输出“Ostrich”（鸵鸟）。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/df006b59b356b121b9c5e35f1b35b65f411b8f6211318cdfe8a1d8f35d564cb5.jpg)  
图 12.15 交通公路标志牌被攻击案例一  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/e3aec336be829b5369dcdddb8c4c348d6d1191ba00f9197dd9cb3437037517a7.jpg)  
图 12.16 交通公路标志牌被攻击案例二  

还有一个令人惊艳的攻击方式，就是在模型里面开一个后门。与之前的攻击都是在测试的阶段才展开不同，这种攻击是在训练阶段就展开的。举例来说，假设我们要让一张图片被识别错误，从鱼被误判为狗。第一种方法，如果我们直接在训练集里面加很多鱼的图片，并且把鱼的图片都标注的为狗，这样训练出来的模型就会把鱼识别为狗，但是这种方法是行不通的，原因在于如果有人去检查训练数据，就会发现这个训练数据有问题。所以第二种方法，我们在训练阶段加的图片是正常的图片，并且它们的标注也都是正确的，拿这样的数据进行训练，让分类器进行错误识别，如图 12.18 所示。这样的话，我们的模型就会在测试的时候，把鱼识别为狗，而且我们的训练数据也是正常的，没有问题的。第二种方法可行，并且有研究人员做了相关的工作，具体的方法是在训练数据中加一些特别的，人看起来没有问题，但实际上有问题的数据，这些数据会让模型在训练的时候开一个后门，让模型在测试的时候识别错误，而且只会对某一张图片识别错误，对其他的图片识别没有影响。这种攻击方式是非常隐蔽的，因为我们的训练数据是正常的，而且我们的模型也是正常的，直到有人拿这张图片来攻击你的模型的时候，我们才会发现这个模型被攻击了。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/f7e674d817e725732c4070feb090c04aaaaeaa5d339a1e05c6f8fc62b5ccca4f.jpg)  
图 12.17 对抗重编程案例分析  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/8ca457b6acb749cbe76fe759ea085dc8225ecf08c37315e3c608e093dd6e6f6c.jpg)  
图 12.18 基于后门的攻击行为  

这个开后门的方式还是非常危险的，现在的人脸识别系统被广泛应用，如果今天的人脸识别系统是用一个免费公开数据集来训练的，而这个数据集里面有一张图片是有问题的。然后我们自己使用这个数据集训练完以后，都会觉得这个数据集很好用又免费，训练出来正确率也很高。但是一旦这个系统，只要看到某个人的图片，就会被误判为其他人，从而使用你自己的信息做一些违法的行为，这个是非常可怕并且有社会危害的。所以我们在使用别人的数据集的时候，一定要小心，要看一下这个数据集是不是有问题，是不是有后门。当然这个基于后门的攻击也不是那么容易成功的，里面会有很多的限制，比如模型和训练方式都会直接影响基于后门的方法能否成功。  

## 12.7 防御方式中的被动防御  

以上我们介绍的都是各种攻击的方式，所以接下来我们继续介绍对应的防御方式。防御方式可以分为两类，一类是被动防御，一类是主动防御。被动防御就是已经训练好的模型不动，同时在模型前面加一个“盾牌”，一个滤波器，如图 12.19 所示。我们期待本来图片加上攻击信号可以骗网络，但是这个滤波器可以削减攻击信号的威力。一般的图片不会受到影响这个附加滤波器的影响，但是攻击信号通过滤波器后就会失去威力，让我们的原始网络不会识别错误。我们要设计的滤波器其实也很简单，把图片稍微模糊一点就可以把攻击信号给削弱掉。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/79a7d24f72e3e818f6e5355e8fb3c39718497ff1bea0a089af5b1ab2ce9a0b66.jpg)  
图 12.19 被动防御  

举例来说，如图 12.20 所示，左上角是加上了非常小的噪声以后系统识别为键盘的图片。现在我们把这张图片做一个非常轻微的平滑模糊化，变为右上角的图片。再将其输入到同一个图像识别系统中，我们就会发现识别结果变成是正确的虎斑猫了。所以这个滤波器的功能就是把攻击信号给削弱掉，让我们的原始网络不会识别错误。这个方法可行的原因只有某一个方向上的某一种攻击的信号才能够攻击图像成功，并不是随便的一个噪声都可以攻击成功。对于这个特殊的噪声我们加上平滑模糊化以后，那个攻击成功的噪声就改变了，它也就失去攻击的威力。但是这个新加的平滑对原来的图片影响很小，所以我们的原始网络还是可以正确识别的。  

当然事物都是有两面性的，这种模糊化的方法也是有一些副作用的。比如本来完全没有被攻击的图片，我们把它稍微平滑模糊化以后，其虽然还是可以正确识别，但是它的置信的分数就下降了，如图 12.20 下方的案例所示。所以像这种平滑模糊化的滤波器，我们要有限制的去使用，使用的太过分的话它就会造成副作用，导致原来正常的图像也会识别出错。  

其实像这样子的被动防御的方法还有很多，除了做平滑模糊化以外，还有其他更加精细的做法，如图 12.21 所示。有一系列的方法是直接对图像做压缩再解压缩。比如我们一张图片存成 JPEG 格式后，它就会失真，但也许失真这一件事情就可以让被攻击的图片失去它的攻击威力。所以这种图像压缩如果会失真的话，那可能攻击的信号受到的影响是比较大的，通过这种方法就可以保护原始模型。还有另外一种基于生成的方法，即给一张图片，然后让生成器生成一张和输入一模一样的图片。对生成器而言，它在训练的时候从来没有看过某些噪声，所以它很小概率可以复现出可以攻击成功的噪声。所以生成出的图片就不会有攻击的噪声，这样我们的原始模型就不会被攻击了，借此可以达到防御的效果。  

被动的防御其实有一个非常大的弱点，虽然模糊化非常有效，但是如果一旦被别人知道我们在用模糊化这种防御的方法的话，那么这种防御就失去了作用。我们可以完全把模糊化想成是网络的第一层，等于就是在原始的网络前面多加了一层，所以假设别人知道我们的网络前面多加了这一层，那直接把多加这一层同样地放到攻击的过程中就可以了。攻击的时候产生一个相反的信号，就可以躲过模糊化这种防御方式了。所以这种被动的防御方式，它既强大也不强大，它强大就是假设别人不知道我们有用这一招，它就非常有效。一旦别人知道我们的招数，那这种被动防御的方法就会瞬间失去作用。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/003856b21ad5f31c6a7493154de2d13259b0e13bf6b58ec71b1084b30043ef6d.jpg)  
图 12.20 被动防御中滤波器的功能  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/8c8f70623fc27549647190e7cfa8e5a2827610156a4660ffba433edf0289a61b.jpg)  
图 12.21 被动防御中图像压缩与基于生成的方法  

这里再介绍一种强化版的被动防御的方法，它叫做随机化防御。这个方法的思路是，我们在做防御的时候，不要只做一种防御，而是做很多种防御。直觉思路上比较好理解，就是怎么样才不会被别人猜中你的下一招，有一些欲欺敌先瞒内的思想在里面。我们在做防御的时候，加上各种不同的防御方式。比如对于我们现在的图片，我们可以随机选择把它放大或缩小，任意改变它的大小，然后将其贴到某一个灰色的背景上，当然贴的位置也可以随机。做完以上操作后，我们再将其输入给图像识别系统，也许透过这种随机的防御，就有办法挡住攻击。但其实这种所谓的随机化防御也有问题，假设别人知道我们随机的分布的话，其实还是有可能攻破这种防御方式的。比如用我们之前介绍的通用攻击就可以解决，其思路是，找一个攻击的信号，可以攻破所有图片的变化方式，这样的随机化方式还是有可能被突破的。  

## 12.8 防御方式中的主动防御  

我们继续介绍防御中的第二种防御方式——主动防御。主动防御的思路是，我们在训练模型的时候，一开始就要训练一个比较不会被攻破的强鲁棒性的模型，这种的训练方式被称为对抗训练。对抗训练就是我们在训练的时候，不要只用原始的训练数据，还要加入一些攻击的数据，如图 12.22 所示。具体来说，我们有一些训练数据，这个和一般的训练数据是一样的，我们以图像举例，并且使用 $x$ 来表示，其对应的标签用 $\hat{y}$ 来表示。然后使用训练数据训练一个模型，并且在训练阶段就对这个模型进行攻击。我们将训练的数据都增加一些噪声从而产生一些攻击的数据，这些被攻击后的图像用 $\tilde{x}$ 来表示。我们将训练数据里面的每一张图片都拿出来进行攻击，攻击完以后再把这些被攻击过后的图片标上正确的标签 $\hat{y}$ ，这样就可以将我们就产生了新的数据集，我们用 $X^{\prime}$ 来表示，这个数据集就会让机器产生错误。接着，同时使用 $X^{\prime}$ 和原始的数据集 $X$ 进行训练，这样就可以训练出一个比较强鲁棒性的模型了。  

![](https://cdn.jsdelivr.net/gh/makaspacex/PictureZone@main/libs/leedl/images/0cf8494f2de200a0b3c3cb9a88ccb908310ceaab2edee994050053b09223e41d.jpg)  
图 12.22 防御方式中的主动防御方法  

所以这整个对抗训练的流程就是，我们先训练好一个模型，然后看看这个模型有没有什么漏洞，把漏洞找出来，并且填好漏洞，这样循环往复最后就可以训练出一个比较强鲁棒性的模型了。这种方法可以被视为一种数据增强的方法，因为我们产生了更多的图片 $\tilde{x}$ ，把这些新图片加到原始的训练数据里面就等于做了数据增强。所以有的研究者也会把对抗训练当做一个单纯数据增强的方法，就算没有人要攻击我们的模型，我们还可以用这样的方法产生更多的数据，并用于训练。这样可以让我们原始的模型，泛化性能更优。  

当时对抗训练也有一个非常大的缺点，就是它不见得挡得住新的攻击方式。具体来说，假设我们今天在找 $\tilde{x}$ 的时候用的是算法一二三四，然后接下来有人在实际攻击的时候使用算法五去攻击我们的模型，这样就可能会成功地规避目前的对抗训练技术。所以如果今天实际上攻击我们模型的方法，并没有在对抗训练的时候被考虑过，那对抗训练也不见得能够挡住新的攻击算法。另外，对抗训练它需要非常大的运算资源。因为本来在训练普通模型的时候，训练完模型有输出的结果就结束了。但是对于对抗训练，首先我们要花时间找出这些 $\tilde{x}$ ，我们原始数据库中有几张图片，我们就要找出多少张新的 $\tilde{x}$ 。比如说我们有 100 万张图片，我们就要找 100 万个 $\tilde{x}$ ，光做这件事情就已经很花时间了。  

所以总结起来，相对来说攻击是比较容易成功，黑盒攻击也是有可能成功的，防御的难度就会大一些。所以在这一章中，我们先介绍了一些攻击的方式，比如白盒攻击和黑盒攻击，本章介绍了几种经典的防御方法。目前攻击和防御的方法仍然不断地在演化，所以在国际会议中会不断有新的攻击和防御的方法被提出，它们仍然在以对手的方式独自进化中。